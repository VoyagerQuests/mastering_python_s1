---
title: "Mastering Python Type Hints / Annotations"
author: "Hanz van Aardt"
format:
  revealjs:
    width: 1600
    height: 1200
    margin: 0.1
    css: styles.css
    transition: slide
    transition-speed: fast
    execute:
      echo: true
      ansi: false
      error: true
theme: dark
---

## {auto-animate=true}
<h2 data-id="title">No type hints / annotations</h2>

```{python}
def say_hi(name):
    return f"Hey {name.strip().title()}!"
```

## {auto-animate=true}
<h2 data-id="title">Comments get stale quickly</h2>

```{python}
#| code-line-numbers: "|2-5,8"
def say_hi(name):
    """
    Input: name: str (no other type supported)
    Output: str
    """
    return f"Hey {name.strip().title()}!"
```

## {auto-animate="true"}
<h2 data-id="title">Correct usage...</h2>

```{python}
def say_hi(name):
    """
    Input: name: str (no other type supported)
    Output: str
    """
    return f"Hey {name.strip().title()}!"

print(say_hi("  zerbial supra "))
```
## {auto-animate=true}
<h2 data-id="title">Incorrect usage...no type checker warning</h2>

```{python}
#| code-line-numbers: "10"
def say_hi(name):
    """
    Input: name: str (no other type supported)
    Output: str
    """
    return f"Hey {name.strip().title()}!"

print(say_hi(["  arion silvaris "])) # <1>
```
1. No type hint is shown!

## {auto-animate=true}
<h2 data-id="title">With type hints / annotations</h2>

```{python}
#| code-line-numbers: "|1"
def say_hi(name: str) -> str:
    return f"Hey {name.strip().title()}!" 

```

## {auto-animate=true}
<h2 data-id="title">Type checker warnings will now guide you</h2>

```{.python}
def say_hi(name: str) -> str:
    return f"Hey {name.strip().title()}!" 

print(say_hi(["  boromir denethorian "])) # <1>

```
1. Argument of type "list[str]" cannot be assigned to parameter "name" of type "str" in function "say_hi"

## {auto-animate=true}
<h2 data-id="title">Python execution remain unchanged</h2>

```{python}
def say_hi(name: str) -> str:
    return f"Hey {name.strip().title()}!" 

print(say_hi(["  boromir denethorian "])) # <1>

```
1. Argument of type "list[str]" cannot be assigned to parameter "name" of type "str" in function "say_hi"

## {auto-animate=true}
<h2 data-id="title">What is this function’s expected type?</h2>

```{python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total
```

## {auto-animate=true}
<h2 data-id="title">No IDE guidance on correct usage</h2>

```{python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total

print(
    "Total character count: ",
    total_character_count("Flee you fools! You shall not pass!") 
) 

```

## {auto-animate=true}
<h2 data-id="title">No IDE guidance on correct usage</h2>

```{.python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total

print(
    "Total character count: ",
    total_character_count(["Flee ", "you ", "fools! ",
                        "You ", "shall ", "not ", "pass!"]), 
) 

```

## {auto-animate=true}
<h2 data-id="title">No IDE guidance on correct usage</h2>

```{python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total

print(
    "Total character count: ",
    total_character_count(["Flee ", "you ", "fools! ",
                        "You ", "shall ", "not ", "pass!"]), 
) 

```

## {auto-animate=true}
<h2 data-id="title">No IDE guidance on correct usage</h2>

```{.python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total

print( # <1>
    "Total character count: ",
    total_character_count([("Flee ", "you ", "fools! "),
                        ("You ", "shall ", "not ", "pass!")]), 
) 
```
1. Is this a valid function call?

## {auto-animate=true}
<h2 data-id="title">No warnings - issues appear only when executed</h2>

```{python}
def total_character_count(words):
    total = 0
    for char in words:
        total += len(char)
    return total

print("Total character count: ",
     total_character_count([("Flee","you","fools!"),("You","shall","not","pass!")])) # <1>
```
1. No type hint is shown!

## {auto-animate=true}
<h2 data-id="title">Type: expects a string OR a list of strings and returns an integer</h2>

```{python}
#| code-line-numbers: "|1"

def total_character_count(words: str | list[str]) -> int:
    total = 0
    for char in words:
        total += len(char)
    return total
```

## {auto-animate=true}
<h2 data-id="title">Type checker now gives a clear warning</h2>

```{python}
def total_character_count(words: str | list[str]) -> int:
    total = 0
    for char in words:
        total += len(char)
    return total

print(
    "Total character count: ",
    total_character_count("Flee you fools! You shall not pass!") 
) 

print(
    "Total character count: ",
    total_character_count(["Flee ", "you ", "fools! ",
                        "You ", "shall ", "not ", "pass!"]), 
) 

print( # <1>
    "Total character count: ",
    total_character_count([("Flee ", "you ", "fools! "),
                        ("You ", "shall ", "not ", "pass!")]), 
) 
```
1. Argument of type "list[str | tuple[str, str, str, str]]" cannot be assigned to parameter "words" of type "str | list[str]"

## {auto-animate="true"}

<h2 data-id="title">Type checker now gives a clear warning</h2>


<img src="images/type_complaint.png"
     style="width:90%; display:block; margin:auto;" />

## {auto-animate="true"}

<h2 data-id="title">Clear type guidance</h2>

<img src="images/type_hinting.png"
     style="width:75%; display:block; margin:auto;" />


## {auto-animate="true"}
<h2 data-id="title">Safe and flexible functions with clear contracts</h2>


``` {python}
#| code-line-numbers: "|1-2"
from collections.abc import Iterable

def total_character_count(words: Iterable[str]) -> int:
    total = 0
    for char in words:
        total += len(char)
    return total
```

## {auto-animate="true"}
<h2 data-id="title">The magic of type hints / annotations!</h2>

``` {python}
from collections.abc import Iterable

def total_character_count(words: Iterable[str]) -> int:
    total = 0
    for char in words:
        total += len(char)
    return total

print("Count: ",total_character_count(["Hello", " world!"]))  # list of strings
print("Count: ",total_character_count(("Hello", " world!")))  # tuple of strings
print("Count: ",total_character_count({"Hello", " world!"}))  # set of strings
print("Count: ",total_character_count(word for word in ["Hello", " world!"])) # generator yielding strings
print("Count: ",total_character_count(iter(["Hello", " world!"]))) # iterator of strings
print("Count: ",total_character_count("Hello world!"))  
print("Count: ",total_character_count([("Hello"," world!")])) # <1>
```
1. Argument of type "Literal[12345]" cannot be assigned to parameter "words" of type "Iterable[str]"

## {auto-animate="true"}
<h2 data-id="title">Manage character data in a role-playing game</h2>

``` {python}
def update_attribute(character, attribute_name, delta):

    if attribute_name not in character["attributes"]:
        raise ValueError("Unknown attribute")

    character["attributes"][attribute_name] += delta

    return character
```
<h3 data-id="title">We cannot determine the contract from this code</h2>


## {auto-animate="true"}
<h2 data-id="title">Comment-based type definitions</h2>

``` {python}
def update_attribute(character, attribute_name, delta):
    """
    Update a character's attribute by adding a delta value.

    character: a dictionary representing the character.
        Expected structure:
        {
            "name": str,
            "attributes": {
                "Might": int,
                "Agility": int,
                "Vitality": int,
                ...
            }
        }

    attribute_name: the name of the attribute to update (string)
    delta: the amount to add or subtract (integer)

    Returns the updated character dictionary.
    """

    if attribute_name not in character["attributes"]:
        raise ValueError("Unknown attribute")

    character["attributes"][attribute_name] += delta

    return character
```

## {auto-animate="true"}
<h2 data-id="title">Spot the mistakes</h2>

``` {python}

#| code-line-numbers: "|3,4"
character: Character = {
    "name": "Aelar",
    "attribute": {
        "might": 10,
        "Agility": 8,
        "Vitality": 12,
        "Insight": 14,
        "Arcana": 16,
        "Presence": 11,
    },
}

print(character)
```

## {auto-animate="true"}
<h2 data-id="title">A perfect function call breaks!</h2>

``` {python}
update_attribute(character, "Might", 200)
```

## {auto-animate="true"}
<h2 data-id="title">Literal restricts to one of a fixed set of exact values</h2>

``` {python}
from typing import Literal


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]

```
<h2 data-id="title">Still just a type - no runtime protection.</h2>

## {auto-animate=true}
<h2 data-id="title">TypedDict defines a dictionary’s shape.</h2>

``` {python}
#| code-line-numbers: "|14-20"
from typing import TypedDict, Literal


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]


class Attributes(TypedDict):
    Might: int
    Agility: int
    Vitality: int
    Insight: int
    Arcana: int
    Presence: int

```

## {auto-animate="true"}
<h2 data-id="title">This shows types built by composing other types</h2>

``` {python}
#| code-line-numbers: "|23-25"
from typing import TypedDict, Literal


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]


class Attributes(TypedDict):
    Might: int
    Agility: int
    Vitality: int
    Insight: int
    Arcana: int
    Presence: int


class Character(TypedDict):
    name: str
    attributes: Attributes
```

## {auto-animate="true"}
<h2 data-id="title">Types will ensure correct usage of this complex function</h2>

``` {python}
#| code-line-numbers: "28-34|"
from typing import TypedDict, Literal


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]


class Attributes(TypedDict):
    Might: int
    Agility: int
    Vitality: int
    Insight: int
    Arcana: int
    Presence: int


class Character(TypedDict):
    name: str
    attributes: Attributes


def update_attribute(
    character: Character,
    attribute_name: AttributeName,
    delta: int,
) -> Character:
    character["attributes"][attribute_name] += delta
    return character
```

## {auto-animate="true"}
<h2 data-id="title">Example usage</h2>

``` {python}
#| code-line-numbers: ""
character: Character = {
    "name": "Aelar",
    "attributes": {
        "Might": 10,
        "Agility": 8,
        "Vitality": 12,
        "Insight": 14,
        "Arcana": 16,
        "Presence": 11,
    },
}

print(character)
```
## {auto-animate="true"}
<h2 data-id="title">We still do not have runtime data integrity protection</h2>

``` {python}
#| code-line-numbers: ""
character: Character = {
    "name": "Aelar",
    "attributes": {
        "might": 35, # <1>
        "Agility": 65, 
        "Vitality": 12,
        "Insight": "39", # <2>
        "Arcana": 16,
        "Presence": 11,
    },
}

print(character)
```
1. "might" is an undefined item in type "Attributes"
2. "Literal['Big Mistake']" is not assignable to "int"

## {auto-animate="true"}
<h2 data-id="title">Let's take a different approach</h2>

``` {python}
#| code-line-numbers: "2"
from typing import Literal, Annotated
from pydantic import BaseModel, Field, ConfigDict


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]
```

## {auto-animate="true"}
<h2 data-id="title">Attach metadata to a type without changing its meaning.</h2>

``` {python}
#| code-line-numbers: "15-22"
from typing import Literal, Annotated
from pydantic import BaseModel, Field, ConfigDict


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]


AttributeValue = Annotated[
    int, 
    Field(
        description="Attribute value can be between 1 and 100",
        ge=1, 
        le=100
        ),
    ]

```

## {auto-animate="true"}

``` {python}
#| code-line-numbers: "25-27"

from typing import Annotated
from pydantic import BaseModel, ConfigDict, Field

BaseAttrValue = Annotated[int, Field(ge=1, le=100)]


class Attributes(BaseModel):
    model_config = ConfigDict(validate_assignment=True)

    might: Annotated[
        BaseAttrValue, Field(alias="Might", description="Physical strength")
    ]
    agility: Annotated[
        BaseAttrValue, Field(alias="Agility", description="Speed and reflexes")
    ]
    vitality: Annotated[
        BaseAttrValue, Field(alias="Vitality", description="Health and endurance")
    ]
    insight: Annotated[
        BaseAttrValue, Field(alias="Insight", description="Perception and discernment")
    ]
    arcana: Annotated[
        BaseAttrValue, Field(alias="Arcana", description="Master arcane subjects")
    ]
    presence: Annotated[
        BaseAttrValue, Field(alias="Presence", description="Charisma and influence")
    ]

```

## {auto-animate="true"}

``` {python}
from typing import Annotated
from enum import Enum
from pydantic import BaseModel, ConfigDict, Field

BaseAttrValue = Annotated[int, Field(ge=1, le=100)]


class Attributes(BaseModel):
    model_config = ConfigDict(validate_assignment=True)

    might: Annotated[
        BaseAttrValue, Field(alias="Might", description="Physical strength")
    ]
    agility: Annotated[
        BaseAttrValue, Field(alias="Agility", description="Speed and reflexes")
    ]
    vitality: Annotated[
        BaseAttrValue, Field(alias="Vitality", description="Health and endurance")
    ]
    insight: Annotated[
        BaseAttrValue, Field(alias="Insight", description="Perception and discernment")
    ]
    arcana: Annotated[
        BaseAttrValue, Field(alias="Arcana", description="Master arcane subjects")
    ]
    presence: Annotated[
        BaseAttrValue, Field(alias="Presence", description="Charisma and influence")
    ]


class Character(BaseModel):
    name: str
    attributes: Attributes


class UpdateAttributeRequest(BaseModel):
    character_id: 

)
```