---
title: "TypedDict | Literal to Pydantic"
format:
  revealjs:
    width: 1600
    height: 1200
    margin: 0.1
    css: styles.css
    transition: slide
    transition-speed: fast
    execute:
      echo: true
      ansi: false
      error: true
theme: dark
---

```{python}
#| include: false
%xmode Plain
```

## {data-visibility="hidden"}
<h2 data-id="title">From Literal and TypedDict to Pydantic</h2>

``` {python}
#| code-line-numbers: ""
from typing import TypedDict, Literal


AttributeName = Literal[
    "Might",
    "Agility",
    "Vitality",
    "Insight",
    "Arcana",
    "Presence",
]


class Attributes(TypedDict):
    Might: int
    Agility: int
    Vitality: int
    Insight: int
    Arcana: int
    Presence: int


class Character(TypedDict):
    name: str
    attributes: Attributes


def update_attribute(
    character: Character,
    attribute_name: AttributeName,
    new_value: int,
) -> Character:
    character["attributes"][attribute_name] = new_value
    return character
```

## {data-visibility="hidden"}
<h2 data-id="title">Example usage</h2>

``` {python}
#| code-line-numbers: ""
character: Character = {
    "name": "Aelar",
    "attributes": {
        "Might": 10,
        "Agility": 8,
        "Vitality": 12,
        "Insight": 14,
        "Arcana": 16,
        "Presence": 11,
    },
}

print(character)
```

## {data-visibility="hidden"}
<h2 data-id="title">The Type Checker will now catch mistakes early</h2>

``` {python}
#| code-line-numbers: ""
character: Character = {
    "name": "Aelar",
    "attributes": {
        "might": 35, # <1>
        "Agility": 65, 
        "Vitality": 12,
        "Insight": "39", # <2>
        "Arcana": 16,
        "Presence": 11,
    },
}

```
1. "might" is an undefined item in type "Attributes"
2. "Literal['39']" is not assignable to "int"

## {data-visibility="hidden"}
<h2 data-id="title">We still do not have runtime data integrity protection</h2>

``` {python}
#| code-line-numbers: ""
character: Character = {
    "name": "Aelar",
    "attributes": {
        "might": 35, # <1>
        "Agility": 65, 
        "Vitality": 12,
        "Insight": "39", # <2>
        "Arcana": 16,
        "Presence": 11,
    },
}

print(character)
```
1. "might" is an undefined item in type "Attributes"
2. "Literal['39']" is not assignable to "int"

## {auto-animate="true"}
<h2 data-id="title">Let's combine type annotations with Pydantic</h2>

``` {python}
#| code-line-numbers: "|2"
from typing import Annotated
from pydantic import BaseModel, Field, ConfigDict
```

## {auto-animate="true"}
<h2 data-id="title">Attach metadata to a type without changing its meaning</h2>

``` {python}
#| code-line-numbers: "|5-6"
from typing import Annotated
from pydantic import BaseModel, Field, ConfigDict


BaseAttrValue = Annotated[int, Field(ge=1, le=100)]
OptionalAttrValue = BaseAttrValue | None

```

## {auto-animate="true"}
<h2 data-id="title">Example Pydantic BaseModel class</h2>

``` {python}
#| code-line-numbers: "8-36|10|11,16|12|34-36"
from typing import Annotated
from pydantic import BaseModel, ConfigDict, Field

BaseAttrValue = Annotated[int, Field(ge=1, le=100)]
OptionalAttrValue = BaseAttrValue | None


class Attributes(BaseModel):
    model_config = ConfigDict(
        validate_assignment=True,
        populate_by_name=True,
        extra="forbid",
    )

    might: Annotated[
        OptionalAttrValue, Field(alias="Might", description="Physical strength")
    ] = None
    agility: Annotated[
        OptionalAttrValue, Field(alias="Agility", description="Speed and reflexes")
    ] = None
    vitality: Annotated[
        OptionalAttrValue, Field(alias="Vitality", description="Health and endurance")
    ] = None
    insight: Annotated[
        OptionalAttrValue, Field(alias="Insight", description="Perception and discernment")
    ] = None
    arcana: Annotated[
        OptionalAttrValue, Field(alias="Arcana", description="Master arcane subjects")
    ] = None
    presence: Annotated[
        OptionalAttrValue, Field(alias="Presence", description="Charisma and influence")
    ] = None

class Character(BaseModel):
    name: str
    attributes: Attributes
```

## {auto-animate="true"}
<h2 data-id="title">Partial update function using Pydantic validation</h2>

``` {python}
#| code-line-numbers: "43-50|44|45|46|47|48-50"

import sys
sys.tracebacklimit = 0

from typing import Annotated
from pydantic import BaseModel, ConfigDict, Field

BaseAttrValue = Annotated[int, Field(ge=1, le=100)]
OptionalAttrValue = BaseAttrValue | None


class Attributes(BaseModel):
    model_config = ConfigDict(
        validate_assignment=True,
        populate_by_name=True,
        extra="forbid",
    )

    might: Annotated[
        OptionalAttrValue, Field(alias="Might", description="Physical strength")
    ] = None
    agility: Annotated[
        OptionalAttrValue, Field(alias="Agility", description="Speed and reflexes")
    ] = None
    vitality: Annotated[
        OptionalAttrValue, Field(alias="Vitality", description="Health and endurance")
    ] = None
    insight: Annotated[
        OptionalAttrValue, Field(alias="Insight", description="Perception and discernment")
    ] = None
    arcana: Annotated[
        OptionalAttrValue, Field(alias="Arcana", description="Master arcane subjects")
    ] = None
    presence: Annotated[
        OptionalAttrValue, Field(alias="Presence", description="Charisma and influence")
    ] = None


class Character(BaseModel):
    name: str
    attributes: Attributes


def update_attributes(
    character: Character,
    new_attributes: Attributes,
) -> None:
    updates = new_attributes.model_dump(exclude_unset=True, exclude_none=True)

    for field, value in updates.items():
        setattr(character.attributes, field, value)
```

## {auto-animate="true"}
<h2 data-id="title">Creating a Pydantic-based object</h2>
``` {python}
# Create an attribute object
attributes1 = Attributes(
    might=1, agility=1, vitality=1, insight=1, arcana=1, presence=1
)
# Create a character named Silvara using the attribute object
silvara = Character(name="Silvara", attributes=attributes1)
print("Character before update:")
print(silvara.model_dump_json())
```

## {auto-animate="true"}
<h2 data-id="title">Multiple updates</h2>

``` {python}
#| code-line-numbers: "10-13"

# Create an attribute object
attributes1 = Attributes(
    might=1, agility=1, vitality=1, insight=1, arcana=1, presence=1
)
# Create a character named Silvara using the attribute object
silvara = Character(name="Silvara", attributes=attributes1)
print("Character before update:")
print(silvara.model_dump_json())

# Update attributes (Correct)
update_attributes(silvara, Attributes(might=5, arcana=10, presence=15))
print("Character after update")
print(silvara.model_dump_json())
```

## {auto-animate="true"}
<h2 data-id="title">Annoted type constraints are enforced by Pydantic</h2>

``` {python}
#| code-line-numbers: ""

import sys
sys.tracebacklimit = 0

# Update attributes (Invalid)
update_attributes(silvara, Attributes(might=120, arcana=10, presence=15))
print("Character after update")
print(silvara.model_dump_json())
```

## {auto-animate="true"}
<h2 data-id="title">Results of the update</h2>

``` {python}
#| code-line-numbers: ""

print("Character after update")
print(silvara.model_dump_json())
```

## {auto-animate="true"}
<h2 data-id="title">Invalid attributes are now rejected</h2>

``` {python}
#| code-line-numbers: ""
data = {
    "name": "Aelar",
    "attributes": {
        "mightt": 35, # <1>
        "Agility": 65, 
        "Vitality": 12,
        "Insight": 39,
        "Arcana": 16,
        "Presence": 11,
    },
}

character: Character = Character.model_validate(data)

print(character)
```
1. mightt is an invalid argument.

## {auto-animate="true"}
<h2 data-id="title">Pydantic type coercion</h2>

``` {python}
#| code-line-numbers: ""
data = {
    "name": "Aelar",
    "attributes": {
        "Might": 35, 
        "Agility": 65, 
        "Vitality": 12,
        "Insight": "39", # <1>
        "Arcana": 16,
        "Presence": 11,
    },
}

character: Character = Character.model_validate(data)

print(character)
```
1. Pydantic type coercion will by default automatically convert "35":string to 35:int

## {auto-animate="true"}
<h2 data-id="title">Pydantic's populate_by_name setting</h2>

``` {python}
#| code-line-numbers: ""
data = {
    "name": "Aelar",
    "attributes": {
        "Might": 35, 
        "agility": 65, # <1>
        "Vitality": 12,
        "Insight": "39", 
        "Arcana": 16,
        "Presence": 11,
    },
}

character: Character = Character.model_validate(data)

print(character)
```
1. populate_by_name allows you to use attribute alias or name

## {auto-animate=true}
<h2 data-id="title">FastAPI uses Pydantic and type annotations to build API</h2>

```{.python}
#| code-line-numbers: ""
from fastapi import FastAPI
from domain import Character


# -----------------------------
# FastAPI setup
# -----------------------------

app = FastAPI()


@app.post("/characters", response_model=Character)
def create_character(character: Character) -> Character:
    return character
```

## {auto-animate=true}

<h2 data-id="title">Refactor to clean architecture</h2>

``` {python}
#| code-line-numbers: "36-40|42-50|52-54|56-63|65-73,43-54"
from typing import Annotated
from pydantic import BaseModel, ConfigDict, Field
from nanoid import generate

BaseAttrValue = Annotated[int, Field(ge=1, le=100)]
OptionalAttrValue = BaseAttrValue | None


class Attributes(BaseModel):
    model_config = ConfigDict(
        validate_assignment=True,
        populate_by_name=True,
        extra="forbid",
    )

    might: Annotated[
        OptionalAttrValue, Field(alias="Might", description="Physical strength")
    ] = None
    agility: Annotated[
        OptionalAttrValue, Field(alias="Agility", description="Speed and reflexes")
    ] = None
    vitality: Annotated[
        OptionalAttrValue, Field(alias="Vitality", description="Health and endurance")
    ] = None
    insight: Annotated[
        OptionalAttrValue, Field(alias="Insight", description="Perception and discernment")
    ] = None
    arcana: Annotated[
        OptionalAttrValue, Field(alias="Arcana", description="Master arcane subjects")
    ] = None
    presence: Annotated[
        OptionalAttrValue, Field(alias="Presence", description="Charisma and influence")
    ] = None


# Domain Layer Class
class CharacterModel(BaseModel):
    id: str
    name: str
    attributes: Attributes

# Data Transfer Object Models
class CreateCharacterRequestDTO(BaseModel):
    name: str
    attributes: Attributes

class CreateCharacterResponseDTO(BaseModel):
    id: str
    name: str
    attributes: Attributes

# Application Layer Functions
def generate_character_id() -> str:
    return "char_" + generate(size=10)

def update_attributes(
    character: CharacterModel,
    new_attributes: Attributes,
) -> None:
    updates = new_attributes.model_dump(exclude_unset=True, exclude_none=True)

    for field, value in updates.items():
        setattr(character.attributes, field, value)

def create_character_use_case(
    request: CreateCharacterRequestDTO,
) -> CreateCharacterResponseDTO:
    # Convert DTO â†’ domain model
    character = CharacterModel(
        id=generate_character_id(),
        name=request.name,
        attributes=request.attributes,
    )
```

## {auto-animate=true}

<h2 data-id="title">Delivery Layer: FastAPI</h2>

``` {python}
#| code-line-numbers: "9|12|13-14|15-16|"
from fastapi import FastAPI
from domain import CharacterModel, CreateCharacterRequestDTO, CreateCharacterResponseDTO, create_character_use_case


# -----------------------------
# FastAPI setup
# -----------------------------

app = FastAPI()


@app.post("/characters", response_model=CreateCharacterResponseDTO)
def create_character(
    request: CreateCharacterRequestDTO,
) -> CreateCharacterResponseDTO:
    return create_character_use_case(request)

```

## {auto-animate=true}

<h2 data-id="title">Delivery Layer: Command Line Interface</h2>

``` {python}
#| code-line-numbers: "1|2|4-9"
import fire
import sys
from domain import Attributes, CreateCharacterRequestDTO, create_character_use_case

sys.tracebacklimit = 0 # Hide traceback for cleaner CLI output

class CharacterCLI:
    def create(self, name: str, **kwargs):
        attributes = Attributes(**kwargs)
        
        request = CreateCharacterRequestDTO(name=name, attributes=attributes)
        response = create_character_use_case(request)
        
        return response.model_dump()

def main() -> None:
    fire.Fire(CharacterCLI)

if __name__ == "__main__":
    main()

```
